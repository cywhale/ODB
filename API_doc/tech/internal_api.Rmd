---
output:
  word_document: default
  html_document: default
---

# **OpenCPU framework for internal web APIs of bio-database**


## *OpenCPU server configuration*

```{r link larvalfish_db using R package, echo=TRUE, warning=FALSE, message=FALSE}
library(data.table)
library(magrittr)
library(odbapi)

args = list(dbhost = larvaHost, dbuser = odbUser, dbname = larvaDB, varname = "metadata_raw",
            taxon ='fish', taxon_lvl = 'species', value_unit = 'perm3', appends='all')
fd0 <- do.call(getBio, args)

# curl https://bio.odb.ntu.edu.tw/ocpu/library/odbapi/R/getBio/json -H "Content-Type: application/json" -d "{\"dbuser\":\"odbguest\",\"dbhost\":\"Your-Host\", \"dbname\":\"Your-DB\",\"value_unit\":\"perm3\"}" -o output.json
library(jsonlite)
library(httr)
# Note: The issue (github.com/opencpu/opencpu/issues/328) indicates that: 
# The default digits argument in jsonlite::toJSON() set to 4. Add JSON encoding parameters as http parameters to the ../json URL. Try appending ?digits=10 or use_signif=TRUE
res <- POST(
    url = "https://bio.odb.ntu.edu.tw/ocpu/library/odbapi/R/getBio/json?use_signif=TRUE",
    body = jsonlite::toJSON(args), encode = "json",
    add_headers("Content-Type" = "application/json")
  )  
httr::stop_for_status(res)
fd0t <- jsonlite::fromJSON(content(res, as="text")) %>% setDT()
```

```{r diffobj, results=FALSE, warning=FALSE, message=FALSE}
diffobj::diffPrint(fd0t, fd0) 
# The difference between the results from API call/R-package is in the number of digits, which can be  solved by ?digits=10.
## < fd0t  ## Results from API                                                                      
## > fd0   ## Results from R-package
##             rank taxarec_id cast_id taxon_count mlength       date time depth 
## <     1: species      33377    1029   0.0011680    14.4 1993-05-21 2200    17 
## >     1: species      33377    1029 0.0011675131    14.4 1993-05-21 2200    17
## <     2: species      33887    1036   0.0009689    16.6 1993-05-22 0400    35 
## >     2: species      33887    1036 0.0009688737    16.6 1993-05-22 0400    3
```
```{r ocpu_session, message=FALSE, warning=FALSE}
library(curl)
print(res$headers$`x-ocpu-session`)
## [1] "x0ef9155ba8e8a5" # Current session ID to keep the state of HTTP REST API
rez <- paste0('https://bio.odb.ntu.edu.tw/ocpu/tmp/',
  res$headers$`x-ocpu-session`,'/R/.val/json?use_signif=TRUE') %>% 
  curl_fetch_memory() # Get the results from a storage of this session generated by OpenCPU
fd0z <- rawToChar(rez$content) %>% jsonlite::fromJSON() %>% setDT() 
all.equal(fd0t, fd0z) # [1] TRUE # Definitely, itâ€™s just from the same storage of this session

```


## *Internal API package: odbapi*
```{r grd_combine, message=FALSE, warning=FALSE}
library(Rcpp) # implement R functions in C++
library(RcppArmadillo) # include a C++ library <Armadillo> for linear algebra that can speedup vector computing
cppsrc <- '
Rcpp::List grid_combineC (SEXP x, SEXP y, int grd_sel) {
  NumericVector xi(x);
  NumericVector yi(y);
  IntegerVector sgnx = sign(xi);
  IntegerVector sgny = sign(yi);
  NumericVector xs = abs(xi);
  NumericVector ys = abs(yi);
  vec xt = floor( xs * 100.00 + 0.5 ) / 100.00;
  vec yt = floor( ys * 100.00 + 0.5 ) / 100.00;
  vec xl = floor(xt);
  vec yl = floor(yt);
  colvec lon(xl.begin(), xl.size(), false); 
  colvec lat(yl.begin(), yl.size(), false);
  if (grd_sel==1) {
    int n = lon.size();
    for(int j = 0; j < n; j++) {
      lon[j] = (xt[j]-lon[j])>=0.5? lon[j]+0.5: lon[j];
      lat[j] = (yt[j]-lat[j])>=0.5? lat[j]+0.5: lat[j];
  } }
  return Rcpp::List::create(Named("lon") = lon % as<vec>(sgnx), Named("lat") = lat % as<vec>(sgny));
}'
sourceCpp("src/grid_combine.cpp") # A simplified C++ source code for odbapi::grdxy_comb. Only test 0.5-degree grid here. 
grid_combineR <- function (x, y, grd_sel=1) {
  xt <- round(x,2);
  yt <- round(y,2)
  xl <- as.integer(xt)
  yl <- as.integer(yt)
  if (grd_sel == 1) { #Simplified case: only test 0.5-degree grid here.
    return(list(lon = ifelse((xt-xl)>=0.5, xl+0.5, xl),
                lat = ifelse((yt-yl)>=0.5, yl+0.5, yl)))    
  }
  return(list(lon = x,lat = y))
}
# Generate a testing data.table with 1 million rows
testdt <- do.call("rbind", replicate(
  30, fd0[,.(show_name, longitude, latitude)], simplify = FALSE)
) # Benchmark: The 1st and 2nd term using Rcpp are just the same, comparing with 3rd term using R, get 3x improvement in speed. 
```

```{r rcpp_benchmark, message=FALSE, warning=FALSE}
res <- microbenchmark::microbenchmark(
    "grd_odbapi" = copy(testdt) %>% .[,c("lon","lat") := grdxy_comb(longitude,latitude,1)],
    "grd_cpp" = copy(testdt) %>% .[,c("lon","lat") := grid_combineC(longitude,latitude,1)],
    "grd_R" = copy(testdt) %>% .[,c("lon","lat") := grid_combineR(longitude,latitude,1)],
    times = 50
) %>% print()
# Unit: milliseconds
#        expr                    min                lq            mean      median              uq               max   neval
#     grd_odbapi  46.5205    54.8443    73.98525    56.3518    63.7002    208.5724        50
#           grd_cpp  46.6298    54.1312    70.14181    57.0878    64.0498    157.3354        50
#             grd_R 136.2115  146.1351  173.52936  150.7337 181.3523    276.3082        50

```

```{r function_getBio, eval=FALSE, message=FALSE, warning=FALSE}
odbapi::getBio( 
  dbuser, dbhost, dbname,
  tblname = NA, varname = NA, taxon = NA, taxon_lvl = "All", 
  season_sel = NA, grd_sel = NA, grd_additive = 0L, 
  lng_rng = NA, lat_rng = NA, date_rng = NA, depth_rng = NA, mesh_rng = NA, 
  lifestages = NA, value_unit = NA, site = NA, appends = NA, parse_simple = TRUE
)
  
```

